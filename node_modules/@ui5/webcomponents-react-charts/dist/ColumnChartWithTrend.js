import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { useConsolidatedRef, usePassThroughHtmlProps } from '@ui5/webcomponents-react-base/dist/hooks';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import { ComposedChart } from '@ui5/webcomponents-react-charts/dist//ComposedChart';
import { ColumnChartWithTrendPlaceholder } from '@ui5/webcomponents-react-charts/dist/ColumnChartWithTrendPlaceholder';
import React, { useMemo, forwardRef } from 'react';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { getTextWidth } from '@ui5/webcomponents-react-charts/dist/Utils';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabel = function useLongestYAxisLabel(dataset, elements) {
  return useMemo(function () {
    var labelLength = 0;
    var primaryElement = elements[0];

    if (dataset instanceof Array && primaryElement) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return primaryElement.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      labelLength = Math.max.apply(Math, _toConsumableArray(dataset.map(resolveAllMeasureLabels).flat().map(getTextWidth)));
      labelLength += 8;
    }

    labelLength = Math.min(labelLength, defaultMaxYAxisWidth);
    return [labelLength, {
      marginLeft: labelLength,
      maxWidth: "calc(100% - ".concat(labelLength + 10, "px)")
    }];
  }, [dataset, elements]);
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var usePrepareTrendMeasures = function usePrepareTrendMeasures(measures, dataset) {
  return useMemo(function () {
    var lineMeasures = [];
    var columnMeasures = [];
    var columnDataset = [];
    measures === null || measures === void 0 ? void 0 : measures.forEach(function (measure, index) {
      if (measure.type === 'bar') {
        var _measure$color;

        columnMeasures.push(_objectSpread(_objectSpread({
          color: (_measure$color = measure.color) !== null && _measure$color !== void 0 ? _measure$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")")
        }, measure), {}, {
          formatter: defaultFormatter
        }));
      }

      if (measure.type === 'line') {
        var _measure$color2;

        lineMeasures.push(_objectSpread(_objectSpread({
          color: (_measure$color2 = measure.color) !== null && _measure$color2 !== void 0 ? _measure$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")")
        }, measure), {}, {
          formatter: defaultFormatter
        }));
        columnMeasures.push(_objectSpread(_objectSpread({}, measure), {}, {
          opacity: 0,
          hideDataLabel: true,
          showDot: false,
          formatter: defaultFormatter
        }));
      }
    });
    dataset === null || dataset === void 0 ? void 0 : dataset.forEach(function (data) {
      var reducedLineValues = {};
      lineMeasures.forEach(function (line) {
        reducedLineValues["__".concat(line.accessor)] = getValueByDataKey(data, line.accessor);
        reducedLineValues[line.accessor] = 0;
      });
      columnDataset.push(_objectSpread(_objectSpread({}, data), reducedLineValues));
    });
    return {
      lineMeasures: lineMeasures,
      columnMeasures: columnMeasures,
      columnDataset: columnDataset
    };
  }, [measures]);
};

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};
var lineTooltipConfig = {
  wrapperStyle: {
    visibility: 'hidden'
  }
};

/**
 * A `ColumnChartWithTrend` is a data visualization where each category is represented by a rectangle, with the height of the rectangle being proportional to the values being plotted amd a trend line which is displayed above the column chart.
 */
var ColumnChartWithTrend = /*#__PURE__*/forwardRef(function (props, ref) {
  var loading = props.loading,
      dataset = props.dataset,
      style = props.style,
      className = props.className,
      slot = props.slot,
      tooltip = props.tooltip,
      onClick = props.onClick,
      noLegend = props.noLegend,
      noAnimation = props.noAnimation;
      props.tooltipConfig;
      var onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      ChartPlaceholder = props.ChartPlaceholder;
  var chartRef = useConsolidatedRef(ref);
  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick', 'onClick']);
  var chartConfig = useMemo(function () {
    return _objectSpread({
      yAxisVisible: false,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      barGap: 3,
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var _usePrepareTrendMeasu = usePrepareTrendMeasures(measures, dataset),
      lineMeasures = _usePrepareTrendMeasu.lineMeasures,
      columnMeasures = _usePrepareTrendMeasu.columnMeasures,
      columnDataset = _usePrepareTrendMeasu.columnDataset;

  var _useLongestYAxisLabel = useLongestYAxisLabel(columnDataset, columnMeasures),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 1),
      yAxisWidth = _useLongestYAxisLabel2[0];

  var columnTooltipConfig = {
    formatter: function formatter(value, name, tooltipProps) {
      var line = lineMeasures.find(function (currLine) {
        return currLine.accessor === tooltipProps.dataKey;
      });

      if (line) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        return line.formatter(tooltipProps.payload["__".concat(line.accessor)]);
      }

      var column = columnMeasures.find(function (currLine) {
        return currLine.accessor === tooltipProps.dataKey;
      });
      return column.formatter(value, name, tooltipProps);
    }
  };
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: chartRef,
    style: _objectSpread({
      display: 'flex',
      flexDirection: 'column',
      height: style === null || style === void 0 ? void 0 : style.height,
      width: style === null || style === void 0 ? void 0 : style.width
    }, style),
    className: className,
    slot: slot
  }, passThroughProps), (dataset === null || dataset === void 0 ? void 0 : dataset.length) !== 0 && /*#__PURE__*/React.createElement(ComposedChart, {
    className: typeof onDataPointClick === 'function' || typeof onClick === 'function' ? 'has-click-handler' : undefined,
    tooltipConfig: lineTooltipConfig,
    noAnimation: noAnimation,
    loading: loading,
    onClick: onClick,
    syncId: 'trend',
    style: _objectSpread(_objectSpread({}, style), {}, {
      height: "calc(".concat(style === null || style === void 0 ? void 0 : style.height, " * 0.2)")
    }),
    dataset: dataset,
    measures: lineMeasures,
    dimensions: dimensions,
    tooltip: tooltip,
    noLegend: true,
    chartConfig: {
      xAxisVisible: false,
      yAxisVisible: false,
      yAxisTicksVisible: false,
      gridHorizontal: false,
      yAxisLabelsVisible: false,
      yAxisWidth: yAxisWidth
    }
  }), /*#__PURE__*/React.createElement(ComposedChart, {
    onLegendClick: onLegendClick,
    tooltipConfig: columnTooltipConfig,
    noAnimation: noAnimation,
    noLegend: noLegend,
    loading: loading,
    onClick: onClick,
    syncId: 'trend',
    ChartPlaceholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : ColumnChartWithTrendPlaceholder,
    dataset: columnDataset,
    measures: columnMeasures,
    dimensions: dimensions,
    chartConfig: chartConfig,
    tooltip: tooltip,
    style: _objectSpread(_objectSpread({}, style), {}, {
      height: "calc(".concat(style === null || style === void 0 ? void 0 : style.height, " * ").concat((dataset === null || dataset === void 0 ? void 0 : dataset.length) !== 0 ? 0.8 : 1, ")")
    }),
    className: typeof onDataPointClick === 'function' || typeof onClick === 'function' ? 'has-click-handler' : undefined
  }));
});
ColumnChartWithTrend.defaultProps = {
  noLegend: false,
  noAnimation: false
};
ColumnChartWithTrend.displayName = 'ColumnChartWithTrend';

export { ColumnChartWithTrend };
//# sourceMappingURL=ColumnChartWithTrend.js.map
