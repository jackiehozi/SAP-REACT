import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { useConsolidatedRef, usePassThroughHtmlProps, useIsRTL } from '@ui5/webcomponents-react-base/dist/hooks';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import { debounce, enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { BulletChartPlaceholder } from '@ui5/webcomponents-react-charts/dist/BulletChartPlaceholder';
import { ChartContainer } from '@ui5/webcomponents-react-charts/dist/components/ChartContainer';
import { ChartDataLabel } from '@ui5/webcomponents-react-charts/dist/components/ChartDataLabel';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/YAxisTicks';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/dist/useLegendItemClick';
import { getTextWidth, resolvePrimaryAndSecondaryMeasures, getCellColors } from '@ui5/webcomponents-react-charts/dist/Utils';
import React, { useMemo, useCallback, useState, useRef, useEffect, forwardRef } from 'react';
import { ComposedChart, CartesianGrid, YAxis, XAxis, ReferenceLine, Label, Tooltip, Legend, Bar, Cell, Brush } from 'recharts';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var useLabelFormatter = function useLabelFormatter(primaryDimension) {
  return useCallback(function (name) {
    if (primaryDimension && typeof primaryDimension.formatter === 'function') {
      return primaryDimension.formatter(name);
    }

    return name;
  }, [primaryDimension]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabel = function useLongestYAxisLabel(dataset, elements) {
  return useMemo(function () {
    var labelLength = 0;
    var primaryElement = elements[0];

    if (dataset instanceof Array && primaryElement) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return primaryElement.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      labelLength = Math.max.apply(Math, _toConsumableArray(dataset.map(resolveAllMeasureLabels).flat().map(getTextWidth)));
      labelLength += 8;
    }

    labelLength = Math.min(labelLength, defaultMaxYAxisWidth);
    return [labelLength, {
      marginLeft: labelLength,
      maxWidth: "calc(100% - ".concat(labelLength + 10, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var useOnClickInternal = function useOnClickInternal(onClick) {
  return useCallback(function (payload, event) {
    if (typeof onClick === 'function') {
      var _payload$activePayloa, _payload$activePayloa2;

      onClick(enrichEventWithDetails(event, {
        payload: payload === null || payload === void 0 ? void 0 : (_payload$activePayloa = payload.activePayload) === null || _payload$activePayloa === void 0 ? void 0 : (_payload$activePayloa2 = _payload$activePayloa[0]) === null || _payload$activePayloa2 === void 0 ? void 0 : _payload$activePayloa2.payload,
        activePayloads: payload === null || payload === void 0 ? void 0 : payload.activePayload
      }));
    }
  }, [onClick]);
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
}; // we need type any due to recharts typing error

var ComparisonLine = function ComparisonLine(props) {
  var x = props.x,
      y = props.y,
      width = props.width,
      height = props.height,
      index = props.index,
      fill = props.fill,
      strokeWidth = props.strokeWidth,
      layout = props.layout;
  var horizontalCalc = {
    x1: strokeWidth ? x + (width - strokeWidth) / 2 - 1 : x - 3,
    x2: strokeWidth ? x + strokeWidth + (width - strokeWidth) / 2 : x + width + 3
  };
  var verticalCalc = {
    y1: strokeWidth ? y + (height - strokeWidth) / 2 - 1 : y - 3,
    y2: strokeWidth ? y + strokeWidth + (height - strokeWidth) / 2 : y + height + 3
  };

  if (layout === 'horizontal') {
    return /*#__PURE__*/React.createElement("line", {
      key: "target-".concat(index),
      x1: horizontalCalc.x1,
      x2: horizontalCalc.x2,
      y1: y,
      y2: y,
      stroke: fill,
      strokeWidth: 3
    });
  }

  return /*#__PURE__*/React.createElement("line", {
    key: "target-".concat(index),
    x1: x + width,
    x2: x + width,
    y1: verticalCalc.y1,
    y2: verticalCalc.y2,
    stroke: fill,
    strokeWidth: 3
  });
};

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};

/**
 * The `BulletChart` is used to compare primary and secondary (comparison) values. The primary and additional values
 * are rendered as a stacked Bar Chart while the comparison value is displayed as a line above.
 */
var BulletChart = /*#__PURE__*/forwardRef(function (props, ref) {
  var _chartConfig$secondYA, _ref2, _chartConfig$secondYA3, _chartConfig$secondYA4, _chartConfig$secondYA5, _chartConfig$secondYA6, _chartConfig$secondYA7, _chartConfig$secondYA8, _chartConfig$secondYA9, _chartConfig$secondYA10;

  var loading = props.loading,
      dataset = props.dataset,
      onDataPointClick = props.onDataPointClick,
      noLegend = props.noLegend,
      noAnimation = props.noAnimation,
      tooltipConfig = props.tooltipConfig,
      onLegendClick = props.onLegendClick,
      onClick = props.onClick,
      layout = props.layout,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot,
      syncId = props.syncId,
      ChartPlaceholder = props.ChartPlaceholder;
  var chartRef = useConsolidatedRef(ref);
  var chartConfig = useMemo(function () {
    return _objectSpread({
      yAxisVisible: false,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var sortedMeasures = useMemo(function () {
    return measures.sort(function (measure) {
      if (measure.type === 'comparison') {
        return 1;
      }

      if (measure.type === 'primary') {
        return -1;
      }

      return 0;
    });
  }, [measures]);
  var tooltipValueFormatter = useTooltipFormatter(sortedMeasures);
  var primaryDimension = dimensions[0];

  var _resolvePrimaryAndSec = resolvePrimaryAndSecondaryMeasures(sortedMeasures, chartConfig === null || chartConfig === void 0 ? void 0 : (_chartConfig$secondYA = chartConfig.secondYAxis) === null || _chartConfig$secondYA === void 0 ? void 0 : _chartConfig$secondYA.dataKey),
      primaryMeasure = _resolvePrimaryAndSec.primaryMeasure,
      secondaryMeasure = _resolvePrimaryAndSec.secondaryMeasure;

  var labelFormatter = useLabelFormatter(primaryDimension);
  var dataKeys = sortedMeasures.map(function (_ref) {
    var accessor = _ref.accessor;
    return accessor;
  });
  var colorSecondY = chartConfig.secondYAxis ? dataKeys.findIndex(function (key) {
    var _chartConfig$secondYA2;

    return key === ((_chartConfig$secondYA2 = chartConfig.secondYAxis) === null || _chartConfig$secondYA2 === void 0 ? void 0 : _chartConfig$secondYA2.dataKey);
  }) : 0;
  var onDataPointClickInternal = useCallback(function (payload, eventOrIndex, event) {
    if (typeof onDataPointClick === 'function') {
      if (payload.name) {
        var _payload$value, _payload$index, _payload$dataKey;

        var payloadValueLength = payload === null || payload === void 0 ? void 0 : (_payload$value = payload.value) === null || _payload$value === void 0 ? void 0 : _payload$value.length;
        onDataPointClick(enrichEventWithDetails(event !== null && event !== void 0 ? event : eventOrIndex, {
          value: payloadValueLength ? payload.value[1] - payload.value[0] : payload.value,
          dataIndex: (_payload$index = payload.index) !== null && _payload$index !== void 0 ? _payload$index : eventOrIndex,
          dataKey: payloadValueLength ? Object.keys(payload).filter(function (key) {
            return payload.value.length ? payload[key] === payload.value[1] - payload.value[0] : payload[key] === payload.value && key !== 'value';
          })[0] : (_payload$dataKey = payload.dataKey) !== null && _payload$dataKey !== void 0 ? _payload$dataKey : Object.keys(payload).find(function (key) {
            return payload[key] === payload.value && key !== 'value';
          }),
          payload: payload.payload
        }));
      } else {
        onDataPointClick(enrichEventWithDetails({}, {
          value: eventOrIndex.value,
          dataKey: eventOrIndex.dataKey,
          dataIndex: eventOrIndex.index,
          payload: eventOrIndex.payload
        }));
      }
    }
  }, [onDataPointClick]);
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var onClickInternal = useOnClickInternal(onClick);
  var isBigDataSet = (_ref2 = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30) !== null && _ref2 !== void 0 ? _ref2 : false;
  var primaryDimensionAccessor = primaryDimension === null || primaryDimension === void 0 ? void 0 : primaryDimension.accessor;

  var _useLongestYAxisLabel = useLongestYAxisLabel(dataset, layout === 'vertical' ? dimensions : sortedMeasures),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      yAxisWidth = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);
  var xAxisHeights = useObserveXAxisHeights(chartRef, layout === 'vertical' ? 1 : props.dimensions.length);
  var measureAxisProps = {
    axisLine: chartConfig.yAxisVisible,
    tickLine: tickLineConfig,
    tickFormatter: primaryMeasure === null || primaryMeasure === void 0 ? void 0 : primaryMeasure.formatter,
    interval: 0
  };
  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick', 'onClick']);
  var isRTL = useIsRTL(chartRef);
  var Placeholder = useCallback(function () {
    return /*#__PURE__*/React.createElement(BulletChartPlaceholder, {
      layout: layout,
      measures: measures
    });
  }, [layout, measures]);
  return /*#__PURE__*/React.createElement(ChartContainer, _extends({
    ref: chartRef,
    loading: loading,
    dataset: dataset,
    Placeholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : Placeholder,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, passThroughProps), /*#__PURE__*/React.createElement(ComposedChart, {
    syncId: syncId,
    onClick: onClickInternal,
    stackOffset: "sign",
    margin: marginChart,
    data: dataset,
    layout: layout,
    className: typeof onDataPointClick === 'function' || typeof onClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && dimensions.map(function (dimension, index) {
    var _dimension$interval;

    var AxisComponent;
    var axisProps = {
      dataKey: dimension.accessor,
      interval: (_dimension$interval = dimension === null || dimension === void 0 ? void 0 : dimension.interval) !== null && _dimension$interval !== void 0 ? _dimension$interval : isBigDataSet ? 'preserveStart' : 0,
      tickLine: index < 1,
      axisLine: index < 1,
      allowDuplicatedCategory: index === 0
    };

    if (layout === 'vertical') {
      axisProps.type = 'category';
      axisProps.tick = /*#__PURE__*/React.createElement(YAxisTicks, {
        config: dimension
      });
      axisProps.yAxisId = index;
      axisProps.width = yAxisWidth;
      AxisComponent = YAxis;
      axisProps.orientation = isRTL ? 'right' : 'left';
    } else {
      axisProps.dataKey = dimension.accessor;
      axisProps.tick = /*#__PURE__*/React.createElement(XAxisTicks, {
        config: dimension
      });
      axisProps.xAxisId = index;
      axisProps.height = xAxisHeights[index];
      AxisComponent = XAxis;
      axisProps.reversed = isRTL;
    }

    return /*#__PURE__*/React.createElement(AxisComponent, _extends({
      key: dimension.accessor
    }, axisProps));
  }), layout === 'horizontal' && /*#__PURE__*/React.createElement(YAxis, _extends({}, measureAxisProps, {
    yAxisId: "primary",
    width: yAxisWidth,
    orientation: isRTL ? 'right' : 'left',
    tick: /*#__PURE__*/React.createElement(YAxisTicks, {
      config: primaryMeasure
    })
  })), layout === 'vertical' && /*#__PURE__*/React.createElement(XAxis, _extends({}, measureAxisProps, {
    reversed: isRTL,
    xAxisId: "primary",
    type: "number",
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: primaryMeasure
    })
  })), ((_chartConfig$secondYA3 = chartConfig.secondYAxis) === null || _chartConfig$secondYA3 === void 0 ? void 0 : _chartConfig$secondYA3.dataKey) && layout === 'horizontal' && /*#__PURE__*/React.createElement(YAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    axisLine: {
      stroke: (_chartConfig$secondYA4 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA4 !== void 0 ? _chartConfig$secondYA4 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    },
    tick: /*#__PURE__*/React.createElement(YAxisTicks, {
      config: secondaryMeasure,
      secondYAxisConfig: {
        color: (_chartConfig$secondYA5 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA5 !== void 0 ? _chartConfig$secondYA5 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
      }
    }),
    tickLine: {
      stroke: (_chartConfig$secondYA6 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA6 !== void 0 ? _chartConfig$secondYA6 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ,
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: isRTL ? 'left' : 'right',
    interval: 0,
    yAxisId: "secondary"
  }), ((_chartConfig$secondYA7 = chartConfig.secondYAxis) === null || _chartConfig$secondYA7 === void 0 ? void 0 : _chartConfig$secondYA7.dataKey) && layout === 'vertical' && /*#__PURE__*/React.createElement(XAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    axisLine: {
      stroke: (_chartConfig$secondYA8 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA8 !== void 0 ? _chartConfig$secondYA8 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    },
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: secondaryMeasure,
      secondYAxisConfig: {
        color: (_chartConfig$secondYA9 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA9 !== void 0 ? _chartConfig$secondYA9 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
      }
    }),
    tickLine: {
      stroke: (_chartConfig$secondYA10 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA10 !== void 0 ? _chartConfig$secondYA10 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ,
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: "top",
    interval: 0,
    xAxisId: "secondary",
    type: "number"
  }), layout === 'horizontal' && /*#__PURE__*/React.createElement(XAxis, {
    xAxisId: 'comparisonXAxis',
    hide: true
  }), layout === 'vertical' && /*#__PURE__*/React.createElement(YAxis, {
    yAxisId: 'comparisonYAxis',
    type: 'category',
    hide: true
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    y: layout === 'horizontal' ? chartConfig.referenceLine.value : undefined,
    x: layout === 'vertical' ? chartConfig.referenceLine.value : undefined,
    yAxisId: layout === 'horizontal' ? 'primary' : undefined,
    xAxisId: layout === 'vertical' ? 'primary' : undefined
  }, /*#__PURE__*/React.createElement(Label, null, chartConfig.referenceLine.label)), /*#__PURE__*/React.createElement(Tooltip, _extends({
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    labelFormatter: labelFormatter,
    contentStyle: tooltipContentStyle
  }, tooltipConfig)), !noLegend &&
  /*#__PURE__*/
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), sortedMeasures === null || sortedMeasures === void 0 ? void 0 : sortedMeasures.map(function (element, index) {
    var _element$color, _element$label, _element$color2, _element$color3;

    var chartElementProps = {
      isAnimationActive: noAnimation === false
    };
    var labelPosition = 'top';

    switch (element.type) {
      case 'primary':
      case 'additional':
        chartElementProps.fillOpacity = element.opacity;
        chartElementProps.strokeOpacity = element.opacity;
        chartElementProps.barSize = element.width;
        chartElementProps.onClick = onDataPointClickInternal;
        chartElementProps.stackId = 'A';
        chartElementProps.labelPosition = element.stackId ? 'insideTop' : 'top';

        if (layout === 'vertical') {
          labelPosition = 'insideRight';
        } else {
          labelPosition = 'insideTop';
        }

        break;

      case 'comparison':
        chartElementProps.onClick = onDataPointClickInternal;
        chartElementProps.fill = (_element$color = element.color) !== null && _element$color !== void 0 ? _element$color : 'black';
        chartElementProps.strokeWidth = element.width;
        chartElementProps.shape = /*#__PURE__*/React.createElement(ComparisonLine, {
          layout: layout
        });
        chartElementProps.strokeOpacity = element.opacity;
        chartElementProps.label = false;
        chartElementProps.xAxisId = 'comparisonXAxis';
        chartElementProps.yAxisId = 'comparisonYAxis';
        chartElementProps.dot = !isBigDataSet;
        break;
    }

    if (layout === 'vertical') {
      var _chartConfig$secondYA11;

      chartElementProps.xAxisId = ((_chartConfig$secondYA11 = chartConfig.secondYAxis) === null || _chartConfig$secondYA11 === void 0 ? void 0 : _chartConfig$secondYA11.dataKey) === element.accessor ? 'secondary' : 'primary';
    } else {
      var _chartConfig$secondYA12;

      chartElementProps.yAxisId = ((_chartConfig$secondYA12 = chartConfig.secondYAxis) === null || _chartConfig$secondYA12 === void 0 ? void 0 : _chartConfig$secondYA12.dataKey) === element.accessor ? 'secondary' : 'primary';
    }

    return /*#__PURE__*/React.createElement(Bar, _extends({
      key: element.accessor,
      name: (_element$label = element.label) !== null && _element$label !== void 0 ? _element$label : element.accessor,
      label: isBigDataSet ? null : /*#__PURE__*/React.createElement(ChartDataLabel, {
        config: element,
        chartType: 'bar',
        position: labelPosition
      }),
      stroke: (_element$color2 = element.color) !== null && _element$color2 !== void 0 ? _element$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      fill: (_element$color3 = element.color) !== null && _element$color3 !== void 0 ? _element$color3 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      type: "monotone",
      dataKey: element.accessor
    }, chartElementProps), element.type !== 'comparison' && dataset.map(function (data, i) {
      return /*#__PURE__*/React.createElement(Cell, {
        key: i,
        fill: getCellColors(element, data, index),
        stroke: getCellColors(element, data, index)
      });
    }));
  }), chartConfig.zoomingTool && /*#__PURE__*/React.createElement(Brush, {
    y: 10,
    dataKey: primaryDimensionAccessor,
    tickFormatter: primaryDimension.formatter,
    stroke: ThemingParameters.sapObjectHeader_BorderColor,
    travellerWidth: 10,
    height: 20
  }), props.children));
});
BulletChart.defaultProps = {
  noLegend: false,
  noAnimation: false,
  layout: 'horizontal'
};
BulletChart.displayName = 'BulletChart';

export { BulletChart };
//# sourceMappingURL=BulletChart.js.map
