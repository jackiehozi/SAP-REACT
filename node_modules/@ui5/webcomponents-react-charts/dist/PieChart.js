import _extends from '@babel/runtime/helpers/extends';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/dist/useConsolidatedRef';
import { usePassThroughHtmlProps } from '@ui5/webcomponents-react-base/dist/usePassThroughHtmlProps';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { ChartContainer } from '@ui5/webcomponents-react-charts/dist/components/ChartContainer';
import { PieChartPlaceholder } from '@ui5/webcomponents-react-charts/dist/PieChartPlaceholder';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/dist/useLegendItemClick';
import React, { useCallback, forwardRef, useMemo, isValidElement, cloneElement } from 'react';
import { Text, Sector, Pie, PieChart as PieChart$1, Label, Cell, Tooltip, Legend } from 'recharts';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';

var useOnClickInternal = function useOnClickInternal(onClick) {
  return useCallback(function (payload, event) {
    if (typeof onClick === 'function') {
      var _payload$activePayloa, _payload$activePayloa2;

      onClick(enrichEventWithDetails(event, {
        payload: payload === null || payload === void 0 ? void 0 : (_payload$activePayloa = payload.activePayload) === null || _payload$activePayloa === void 0 ? void 0 : (_payload$activePayloa2 = _payload$activePayloa[0]) === null || _payload$activePayloa2 === void 0 ? void 0 : _payload$activePayloa2.payload,
        activePayloads: payload === null || payload === void 0 ? void 0 : payload.activePayload
      }));
    }
  }, [onClick]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};

var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
}; // we need type any due to recharts typing error

var tooltipItemDefaultStyle = {
  color: 'var (--sapTextColor)'
};
/**
 * A Pie Chart is a type of graph that displays data in a circular graph.
 * The pieces of the graph are proportional to the fraction of the whole in each category.
 *
 * In other words, each slice of the pie is relative to the size of that category in the group as a whole.
 * The entire “pie” represents 100 percent of a whole, while the pie “slices” represent portions of the whole.
 */

var PieChart = /*#__PURE__*/forwardRef(function (props, ref) {
  var _chartConfig$showActi;

  var loading = props.loading,
      dataset = props.dataset,
      noLegend = props.noLegend,
      noAnimation = props.noAnimation,
      tooltipConfig = props.tooltipConfig,
      onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      onClick = props.onClick,
      centerLabel = props.centerLabel,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot,
      ChartPlaceholder = props.ChartPlaceholder;
  var chartConfig = useMemo(function () {
    var _props$chartConfig$ma, _props$chartConfig;

    return _objectSpread({
      margin: _objectSpread({
        right: 30,
        left: 30,
        bottom: 30,
        top: 30
      }, (_props$chartConfig$ma = (_props$chartConfig = props.chartConfig) === null || _props$chartConfig === void 0 ? void 0 : _props$chartConfig.margin) !== null && _props$chartConfig$ma !== void 0 ? _props$chartConfig$ma : {}),
      legendPosition: 'bottom',
      legendHorizontalAlign: 'center',
      paddingAngle: 0,
      outerRadius: '80%',
      resizeDebounce: 250,
      tooltipItemStyle: tooltipItemDefaultStyle
    }, props.chartConfig);
  }, [props.chartConfig]);
  var showActiveSegmentDataLabel = (_chartConfig$showActi = chartConfig.showActiveSegmentDataLabel) !== null && _chartConfig$showActi !== void 0 ? _chartConfig$showActi : true;
  var dimension = useMemo(function () {
    return _objectSpread({
      formatter: defaultFormatter
    }, props.dimension);
  }, [props.dimension]);
  var measure = useMemo(function () {
    return _objectSpread({
      formatter: defaultFormatter
    }, props.measure);
  }, [props.measure]);
  var dataLabel = useCallback(function (props) {
    var hideDataLabel = typeof measure.hideDataLabel === 'function' ? measure.hideDataLabel(props) : measure.hideDataLabel;
    if (hideDataLabel || chartConfig.activeSegment === props.index) return null;

    if ( /*#__PURE__*/isValidElement(measure.DataLabel)) {
      return /*#__PURE__*/cloneElement(measure.DataLabel, _objectSpread(_objectSpread({}, props), {}, {
        config: measure
      }));
    }

    return /*#__PURE__*/React.createElement(Text, _extends({}, props, {
      alignmentBaseline: "middle",
      className: "recharts-pie-label-text"
    }), measure.formatter(props.value));
  }, [measure, chartConfig.activeSegment]);
  var tooltipValueFormatter = useCallback(function (value, name) {
    return [measure.formatter(value), dimension.formatter(name)];
  }, [measure.formatter, dimension.formatter]);
  var chartRef = useConsolidatedRef(ref);
  var onItemLegendClick = useLegendItemClick(onLegendClick, function () {
    return measure.accessor;
  });
  var onClickInternal = useOnClickInternal(onClick);
  var onDataPointClickInternal = useCallback(function (payload, dataIndex, event) {
    if (payload && payload && typeof onDataPointClick === 'function') {
      var _payload$tooltipPaylo, _payload$tooltipPaylo2;

      onDataPointClick(enrichEventWithDetails(event, {
        value: payload.value,
        dataKey: (_payload$tooltipPaylo = payload.tooltipPayload) === null || _payload$tooltipPaylo === void 0 ? void 0 : (_payload$tooltipPaylo2 = _payload$tooltipPaylo[0]) === null || _payload$tooltipPaylo2 === void 0 ? void 0 : _payload$tooltipPaylo2.dataKey,
        name: payload.name,
        payload: payload.payload,
        dataIndex: dataIndex
      }));
    }
  }, [onDataPointClick]);
  var renderActiveShape = useCallback(function (props) {
    var RADIAN = Math.PI / 180;
    var cx = props.cx,
        cy = props.cy,
        midAngle = props.midAngle,
        innerRadius = props.innerRadius,
        outerRadius = props.outerRadius,
        startAngle = props.startAngle,
        endAngle = props.endAngle,
        fill = props.fill,
        payload = props.payload,
        percent = props.percent,
        value = props.value;
    var sin = Math.sin(-RADIAN * midAngle);
    var cos = Math.cos(-RADIAN * midAngle);
    var sx = cx + (outerRadius + 10) * cos;
    var sy = cy + (outerRadius + 10) * sin;
    var mx = cx + (outerRadius + 30) * cos;
    var my = cy + (outerRadius + 30) * sin;
    var ex = mx + (cos >= 0 ? 1 : -1) * 22;
    var ey = my;
    var textAnchor = cos >= 0 ? 'start' : 'end';
    return /*#__PURE__*/React.createElement("g", null, /*#__PURE__*/React.createElement("text", {
      x: cx,
      y: cy,
      dy: 8,
      textAnchor: "middle",
      fill: fill
    }, payload.name), /*#__PURE__*/React.createElement(Sector, {
      cx: cx,
      cy: cy,
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      startAngle: startAngle,
      endAngle: endAngle,
      fill: fill
    }), /*#__PURE__*/React.createElement(Sector, {
      cx: cx,
      cy: cy,
      startAngle: startAngle,
      endAngle: endAngle,
      innerRadius: outerRadius + 6,
      outerRadius: outerRadius + 10,
      fill: fill
    }), showActiveSegmentDataLabel && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("path", {
      d: "M".concat(sx, ",").concat(sy, "L").concat(mx, ",").concat(my, "L").concat(ex, ",").concat(ey),
      stroke: fill,
      fill: "none"
    }), /*#__PURE__*/React.createElement("circle", {
      cx: ex,
      cy: ey,
      r: 2,
      fill: fill,
      stroke: "none"
    }), /*#__PURE__*/React.createElement("text", {
      x: ex + (cos >= 0 ? 1 : -1) * 12,
      y: ey,
      textAnchor: textAnchor,
      fill: fill
    }, measure.formatter(value)), /*#__PURE__*/React.createElement("text", {
      x: ex + (cos >= 0 ? 1 : -1) * 12,
      y: ey,
      dy: 18,
      textAnchor: textAnchor,
      fill: fill
    }, "(".concat((percent * 100).toFixed(2), "%)"))));
  }, [showActiveSegmentDataLabel]);
  var renderLabelLine = useCallback(function (props) {
    var hideDataLabel = typeof measure.hideDataLabel === 'function' ? measure.hideDataLabel(props) : measure.hideDataLabel;
    if (hideDataLabel || chartConfig.activeSegment === props.index) return null;
    return Pie.renderLabelLineItem(undefined, props);
  }, [chartConfig.activeSegment, measure.hideDataLabel]);
  var legendWrapperStyle = useMemo(function () {
    if (chartConfig.activeSegment != null && showActiveSegmentDataLabel) {
      if (chartConfig.legendPosition === 'bottom') {
        return {
          paddingTop: '30px'
        };
      } else if (chartConfig.legendPosition === 'top') {
        return {
          paddingBottom: '30px'
        };
      }
    }

    return null;
  }, [showActiveSegmentDataLabel, chartConfig.activeSegment, chartConfig.legendPosition]);
  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick', 'onClick']);
  return /*#__PURE__*/React.createElement(ChartContainer, _extends({
    dataset: dataset,
    ref: chartRef,
    loading: loading,
    Placeholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : PieChartPlaceholder,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, passThroughProps), /*#__PURE__*/React.createElement(PieChart$1, {
    onClick: onClickInternal,
    margin: chartConfig.margin,
    className: typeof onDataPointClick === 'function' || typeof onClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(Pie, {
    onClick: onDataPointClickInternal,
    innerRadius: chartConfig.innerRadius,
    outerRadius: chartConfig.outerRadius,
    paddingAngle: chartConfig.paddingAngle,
    nameKey: dimension.accessor,
    dataKey: measure.accessor,
    data: dataset,
    animationBegin: 0,
    isAnimationActive: noAnimation === false,
    labelLine: renderLabelLine,
    label: dataLabel,
    activeIndex: chartConfig.activeSegment,
    activeShape: chartConfig.activeSegment != null && renderActiveShape
  }, centerLabel && /*#__PURE__*/React.createElement(Label, {
    position: "center"
  }, centerLabel), dataset && dataset.map(function (data, index) {
    var _measure$colors$index, _measure$colors;

    return /*#__PURE__*/React.createElement(Cell, {
      key: index,
      name: dimension.formatter(getValueByDataKey(data, dimension.accessor, '')),
      fill: (_measure$colors$index = (_measure$colors = measure.colors) === null || _measure$colors === void 0 ? void 0 : _measure$colors[index]) !== null && _measure$colors$index !== void 0 ? _measure$colors$index : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")")
    });
  })), /*#__PURE__*/React.createElement(Tooltip, _extends({
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle,
    itemStyle: chartConfig.tooltipItemStyle,
    labelStyle: chartConfig.tooltipLabelStyle
  }, tooltipConfig)), !noLegend &&
  /*#__PURE__*/
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendWrapperStyle
  }), props.children));
});
PieChart.defaultProps = {
  noLegend: false,
  noAnimation: false
};
PieChart.displayName = 'PieChart';

export { PieChart };
//# sourceMappingURL=PieChart.js.map
