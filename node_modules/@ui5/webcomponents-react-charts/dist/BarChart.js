import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { useConsolidatedRef, usePassThroughHtmlProps, useIsRTL } from '@ui5/webcomponents-react-base/dist/hooks';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import { debounce, enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { BarChartPlaceholder } from '@ui5/webcomponents-react-charts/dist/BarChartPlaceholder';
import { ChartContainer } from '@ui5/webcomponents-react-charts/dist/components/ChartContainer';
import { ChartDataLabel } from '@ui5/webcomponents-react-charts/dist/components/ChartDataLabel';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/YAxisTicks';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/dist/useLegendItemClick';
import { getTextWidth, resolvePrimaryAndSecondaryMeasures, getCellColors } from '@ui5/webcomponents-react-charts/dist/Utils';
import React, { useState, useRef, useMemo, useCallback, useEffect, forwardRef } from 'react';
import { BarChart as BarChart$1, CartesianGrid, XAxis, YAxis, Bar, LabelList, Cell, Legend, ReferenceLine, Label, Tooltip, Brush } from 'recharts';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';

var useCancelAnimationFallback = function useCancelAnimationFallback(noAnimation) {
  var _useState = useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      isMounted = _useState2[0],
      setIsMounted = _useState2[1];

  var cancelAnimationFallback = function cancelAnimationFallback() {
    setIsMounted(false);
    setIsMounted(true);
  };

  var debouncedCancelAnimationFallback = useRef(debounce(cancelAnimationFallback, 1500)).current;

  var handleBarAnimationStart = function handleBarAnimationStart() {
    if (!noAnimation) {
      debouncedCancelAnimationFallback();
    }
  };

  var handleBarAnimationEnd = function handleBarAnimationEnd() {
    if (!noAnimation) {
      debouncedCancelAnimationFallback.cancel();
    }
  };

  return {
    isMounted: isMounted,
    handleBarAnimationStart: handleBarAnimationStart,
    handleBarAnimationEnd: handleBarAnimationEnd
  };
};

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var useLabelFormatter = function useLabelFormatter(primaryDimension) {
  return useCallback(function (name) {
    if (primaryDimension && typeof primaryDimension.formatter === 'function') {
      return primaryDimension.formatter(name);
    }

    return name;
  }, [primaryDimension]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabelBar = function useLongestYAxisLabelBar(dataset, elements) {
  return useMemo(function () {
    var axisWidths = Array(elements.length).fill(0);
    var marginLeft = 0;

    if (dataset instanceof Array && elements) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return elementConfig.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      var allFormattedDataLabels = dataset.map(resolveAllMeasureLabels);
      allFormattedDataLabels.forEach(function (dimensionLabels) {
        dimensionLabels.forEach(function (label, dimensionIndex) {
          axisWidths[dimensionIndex] = Math.max(getTextWidth(label), axisWidths[dimensionIndex]);
        });
      });
      axisWidths = axisWidths.map(function (length) {
        return Math.min(defaultMaxYAxisWidth, length);
      });
      marginLeft = axisWidths.reduce(function (acc, val) {
        return acc + val;
      }, 0);
    }

    return [axisWidths, {
      marginLeft: marginLeft,
      maxWidth: "calc(100% - ".concat(marginLeft + 8, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var useOnClickInternal = function useOnClickInternal(onClick) {
  return useCallback(function (payload, event) {
    if (typeof onClick === 'function') {
      var _payload$activePayloa, _payload$activePayloa2;

      onClick(enrichEventWithDetails(event, {
        payload: payload === null || payload === void 0 ? void 0 : (_payload$activePayloa = payload.activePayload) === null || _payload$activePayloa === void 0 ? void 0 : (_payload$activePayloa2 = _payload$activePayloa[0]) === null || _payload$activePayloa2 === void 0 ? void 0 : _payload$activePayloa2.payload,
        activePayloads: payload === null || payload === void 0 ? void 0 : payload.activePayload
      }));
    }
  }, [onClick]);
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
}; // we need type any due to recharts typing error

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};

var valueAccessor = function valueAccessor(attribute) {
  return function (_ref) {
    var payload = _ref.payload;
    return getValueByDataKey(payload, attribute);
  };
};

/**
 * A `BarChart` is a data visualization where each category is represented by a rectangle, with the width of the rectangle being proportional to the values being plotted.
 */
var BarChart = /*#__PURE__*/forwardRef(function (props, ref) {
  var _chartConfig$secondYA, _chartConfig$secondYA3, _chartConfig$secondYA4, _chartConfig$secondYA5, _chartConfig$secondYA6;

  var loading = props.loading,
      dataset = props.dataset,
      noLegend = props.noLegend,
      noAnimation = props.noAnimation,
      tooltipConfig = props.tooltipConfig,
      onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      onClick = props.onClick,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot,
      syncId = props.syncId,
      ChartPlaceholder = props.ChartPlaceholder;
  var chartConfig = useMemo(function () {
    return _objectSpread({
      margin: {},
      yAxisVisible: true,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      barGap: 3,
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var tooltipValueFormatter = useTooltipFormatter(measures);
  var primaryDimension = dimensions[0];

  var _resolvePrimaryAndSec = resolvePrimaryAndSecondaryMeasures(measures, chartConfig === null || chartConfig === void 0 ? void 0 : (_chartConfig$secondYA = chartConfig.secondYAxis) === null || _chartConfig$secondYA === void 0 ? void 0 : _chartConfig$secondYA.dataKey),
      primaryMeasure = _resolvePrimaryAndSec.primaryMeasure,
      secondaryMeasure = _resolvePrimaryAndSec.secondaryMeasure;

  var dataKeys = measures.map(function (_ref2) {
    var accessor = _ref2.accessor;
    return accessor;
  });
  var colorSecondY = chartConfig.secondYAxis ? dataKeys.findIndex(function (key) {
    var _chartConfig$secondYA2;

    return key === ((_chartConfig$secondYA2 = chartConfig.secondYAxis) === null || _chartConfig$secondYA2 === void 0 ? void 0 : _chartConfig$secondYA2.dataKey);
  }) : 0;
  var chartRef = useConsolidatedRef(ref);
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var labelFormatter = useLabelFormatter(primaryDimension);
  var onDataPointClickInternal = useCallback(function (payload, i, event) {
    if (payload && onDataPointClick) {
      var _value = payload.value.length ? payload.value[1] - payload.value[0] : payload.value;

      onDataPointClick(enrichEventWithDetails(event, {
        dataKey: Object.keys(payload).filter(function (key) {
          return key !== 'value';
        }).find(function (key) {
          return payload[key] === _value;
        }),
        value: _value,
        payload: payload.payload,
        dataIndex: i
      }));
    }
  }, [onDataPointClick]);
  var onClickInternal = useOnClickInternal(onClick);
  var isBigDataSet = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30;
  var primaryDimensionAccessor = primaryDimension === null || primaryDimension === void 0 ? void 0 : primaryDimension.accessor;

  var _useLongestYAxisLabel = useLongestYAxisLabelBar(dataset, dimensions),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      width = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);

  var _useObserveXAxisHeigh = useObserveXAxisHeights(chartRef, 1),
      _useObserveXAxisHeigh2 = _slicedToArray(_useObserveXAxisHeigh, 1),
      xAxisHeight = _useObserveXAxisHeigh2[0];

  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick', 'onClick']);
  var isRTL = useIsRTL(chartRef);

  var _useCancelAnimationFa = useCancelAnimationFallback(noAnimation),
      isMounted = _useCancelAnimationFa.isMounted,
      handleBarAnimationStart = _useCancelAnimationFa.handleBarAnimationStart,
      handleBarAnimationEnd = _useCancelAnimationFa.handleBarAnimationEnd;

  return /*#__PURE__*/React.createElement(ChartContainer, _extends({
    dataset: dataset,
    loading: loading,
    Placeholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : BarChartPlaceholder,
    ref: chartRef,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, passThroughProps), /*#__PURE__*/React.createElement(BarChart$1, {
    syncId: syncId,
    onClick: onClickInternal,
    stackOffset: "sign",
    margin: marginChart,
    layout: "vertical",
    data: dataset,
    barGap: chartConfig.barGap,
    className: typeof onDataPointClick === 'function' || typeof onClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && /*#__PURE__*/React.createElement(XAxis, {
    interval: 0,
    type: "number",
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: primaryMeasure
    }),
    axisLine: chartConfig.xAxisVisible,
    tickLine: tickLineConfig,
    tickFormatter: primaryMeasure === null || primaryMeasure === void 0 ? void 0 : primaryMeasure.formatter,
    height: xAxisHeight,
    reversed: isRTL
  }), ((_chartConfig$secondYA3 = chartConfig.secondYAxis) === null || _chartConfig$secondYA3 === void 0 ? void 0 : _chartConfig$secondYA3.dataKey) && /*#__PURE__*/React.createElement(XAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    axisLine: {
      stroke: (_chartConfig$secondYA4 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA4 !== void 0 ? _chartConfig$secondYA4 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    },
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: secondaryMeasure,
      secondYAxisConfig: {
        color: (_chartConfig$secondYA5 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA5 !== void 0 ? _chartConfig$secondYA5 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
      }
    }),
    tickLine: {
      stroke: (_chartConfig$secondYA6 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA6 !== void 0 ? _chartConfig$secondYA6 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")")
    } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ,
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: "top",
    interval: 0,
    xAxisId: "secondary",
    type: "number"
  }), chartConfig.yAxisVisible && dimensions.map(function (dimension, index) {
    var _dimension$interval;

    return /*#__PURE__*/React.createElement(YAxis, {
      interval: (_dimension$interval = dimension === null || dimension === void 0 ? void 0 : dimension.interval) !== null && _dimension$interval !== void 0 ? _dimension$interval : isBigDataSet ? 'preserveStart' : 0,
      type: "category",
      key: dimension.accessor,
      dataKey: dimension.accessor,
      tick: /*#__PURE__*/React.createElement(YAxisTicks, {
        config: dimension
      }),
      tickLine: index < 1,
      axisLine: index < 1,
      yAxisId: index,
      width: width[index],
      allowDuplicatedCategory: index === 0,
      orientation: isRTL ? 'right' : 'left'
    });
  }), isMounted && measures.map(function (element, index) {
    var _element$label, _element$color, _element$color2;

    return /*#__PURE__*/React.createElement(Bar, {
      stackId: element.stackId,
      fillOpacity: element.opacity,
      key: element.accessor,
      name: (_element$label = element.label) !== null && _element$label !== void 0 ? _element$label : element.accessor,
      strokeOpacity: element.opacity,
      type: "monotone",
      dataKey: element.accessor,
      fill: (_element$color = element.color) !== null && _element$color !== void 0 ? _element$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      stroke: (_element$color2 = element.color) !== null && _element$color2 !== void 0 ? _element$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      barSize: element.width // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ,
      onClick: onDataPointClickInternal,
      isAnimationActive: noAnimation === false,
      onAnimationStart: handleBarAnimationStart,
      onAnimationEnd: handleBarAnimationEnd
    }, /*#__PURE__*/React.createElement(LabelList, {
      data: dataset,
      valueAccessor: valueAccessor(element.accessor),
      content: /*#__PURE__*/React.createElement(ChartDataLabel, {
        config: element,
        chartType: "bar",
        position: 'insideRight'
      })
    }), dataset.map(function (data, i) {
      return /*#__PURE__*/React.createElement(Cell, {
        key: i,
        fill: getCellColors(element, data, index),
        stroke: getCellColors(element, data, index)
      });
    }));
  }), !noLegend &&
  /*#__PURE__*/
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    x: chartConfig.referenceLine.value
  }, /*#__PURE__*/React.createElement(Label, null, chartConfig.referenceLine.label)), /*#__PURE__*/React.createElement(Tooltip, _extends({
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle,
    labelFormatter: labelFormatter
  }, tooltipConfig)), chartConfig.zoomingTool && /*#__PURE__*/React.createElement(Brush, {
    y: 10,
    dataKey: primaryDimensionAccessor,
    tickFormatter: primaryDimension.formatter,
    stroke: ThemingParameters.sapObjectHeader_BorderColor,
    travellerWidth: 10,
    height: 20
  }), props.children));
});
BarChart.defaultProps = {
  noLegend: false,
  noAnimation: false
};
BarChart.displayName = 'BarChart';

export { BarChart };
//# sourceMappingURL=BarChart.js.map
