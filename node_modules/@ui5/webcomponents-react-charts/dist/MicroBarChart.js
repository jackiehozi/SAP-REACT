import _extends from '@babel/runtime/helpers/extends';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { createUseStyles } from 'react-jss';
import { StyleClassHelper } from '@ui5/webcomponents-react-base/dist/StyleClassHelper';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/dist/useConsolidatedRef';
import { usePassThroughHtmlProps } from '@ui5/webcomponents-react-base/dist/usePassThroughHtmlProps';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { BarChartPlaceholder } from '@ui5/webcomponents-react-charts/dist/BarChartPlaceholder';
import { ChartContainer } from '@ui5/webcomponents-react-charts/dist/components/ChartContainer';
import React, { forwardRef, useMemo, useCallback } from 'react';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';

var defaultFormatter = function defaultFormatter(d) {
  return d;
};

var resolveColor = function resolveColor(index) {
  var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (color) {
    var _ThemingParameters$co;

    return (_ThemingParameters$co = ThemingParameters[color]) !== null && _ThemingParameters$co !== void 0 ? _ThemingParameters$co : color;
  }

  return ThemingParameters["sapChart_Sequence_".concat(index % 11 + 1)];
};

var MicroBarChartStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden',
    fontFamily: ThemingParameters.sapFontFamily,
    fontWeight: 'normal',
    width: '100%',
    height: '100%',
    justifyContent: 'space-around'
  },
  barContainer: {
    cursor: 'auto'
  },
  barContainerActive: {
    '&:active': {
      opacity: '0.3 !important'
    },
    cursor: 'pointer'
  },
  labelContainer: {
    display: 'flex',
    justifyContent: 'space-between'
  },
  valueContainer: {
    display: 'flex',
    backgroundColor: ThemingParameters.sapContent_Placeholderloading_Background
  },
  valueBar: {
    height: '100%'
  },
  label: {
    color: ThemingParameters.sapContent_LabelColor,
    display: 'block',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    textOverflow: 'ellipsis',
    fontSize: ThemingParameters.sapFontSmallSize,
    maxWidth: '70%'
  },
  text: {
    paddingLeft: '6px',
    display: 'inline-block',
    overflow: 'hidden',
    fontSize: ThemingParameters.sapFontSmallSize,
    boxSizing: 'border-box',
    whiteSpace: 'nowrap',
    textOverflow: 'ellipsis',
    color: ThemingParameters.sapTextColor,
    textAlign: 'right'
  }
};
var useStyles = createUseStyles(MicroBarChartStyles, {
  name: 'MicroBarChart'
});
/**
 * The `MicroBarChart` compares different values of the same category to each other by displaying them in a compact way.
 */

var MicroBarChart = /*#__PURE__*/forwardRef(function (props, ref) {
  var loading = props.loading,
      dataset = props.dataset,
      onDataPointClick = props.onDataPointClick,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot,
      ChartPlaceholder = props.ChartPlaceholder;
  var classes = useStyles();
  var dimension = useMemo(function () {
    return _objectSpread({
      formatter: defaultFormatter
    }, props.dimension);
  }, [props.dimension]);
  var measure = useMemo(function () {
    return _objectSpread({
      formatter: defaultFormatter
    }, props.measure);
  }, [props.measure]);
  var maxValue = useMemo(function () {
    if (dataset) {
      var _props$maxValue;

      var maxDatasetValue = Math.max.apply(Math, _toConsumableArray(dataset === null || dataset === void 0 ? void 0 : dataset.map(function (item) {
        return getValueByDataKey(item, measure.accessor);
      })));
      return (_props$maxValue = props.maxValue) !== null && _props$maxValue !== void 0 ? _props$maxValue : maxDatasetValue;
    }

    return 0;
  }, [dataset, measure, props.maxValue]);
  var chartRef = useConsolidatedRef(ref);
  var barHeight = measure !== null && measure !== void 0 && measure.width ? "".concat(measure.width, "px") : '4px';
  var onBarClick = useCallback(function (item, index) {
    return function (e) {
      if (typeof onDataPointClick === 'function') {
        onDataPointClick(enrichEventWithDetails(e, {
          dataKey: measure.accessor,
          value: getValueByDataKey(item, measure.accessor),
          payload: item,
          dataIndex: index
        }));
      }
    };
  }, [measure.accessor, onDataPointClick]);
  var barContainerClasses = StyleClassHelper.of(classes.barContainer);

  if (onDataPointClick) {
    barContainerClasses.put(classes.barContainerActive);
  }

  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick']);
  return /*#__PURE__*/React.createElement(ChartContainer, _extends({
    dataset: dataset,
    loading: loading,
    Placeholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : BarChartPlaceholder,
    ref: chartRef,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: 250
  }, passThroughProps), /*#__PURE__*/React.createElement("div", {
    className: classes.container
  }, dataset === null || dataset === void 0 ? void 0 : dataset.map(function (item, index) {
    var _measure$opacity, _measure$colors;

    var dimensionValue = getValueByDataKey(item, dimension.accessor);
    var measureValue = getValueByDataKey(item, measure.accessor);
    var formattedDimension = dimension.formatter(dimensionValue);
    var formattedMeasure = '';

    if (!measure.hideDataLabel) {
      if (measure.DataLabel) {
        formattedMeasure = /*#__PURE__*/React.createElement(measure.DataLabel, {
          value: measureValue,
          config: measure,
          formattedValue: measure.formatter(measureValue)
        });
      } else {
        formattedMeasure = measure.formatter(measureValue);
      }
    }

    return /*#__PURE__*/React.createElement("div", {
      key: dimensionValue,
      className: barContainerClasses.className,
      onClick: onBarClick(item, index)
    }, /*#__PURE__*/React.createElement("div", {
      className: classes.labelContainer
    }, /*#__PURE__*/React.createElement("span", {
      className: classes.label,
      title: formattedDimension
    }, formattedDimension), /*#__PURE__*/React.createElement("span", {
      className: classes.text,
      title: formattedMeasure
    }, measure.hideDataLabel ? '' : formattedMeasure)), /*#__PURE__*/React.createElement("div", {
      className: classes.valueContainer,
      style: {
        opacity: (_measure$opacity = measure === null || measure === void 0 ? void 0 : measure.opacity) !== null && _measure$opacity !== void 0 ? _measure$opacity : 1,
        height: barHeight
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: classes.valueBar,
      style: {
        width: "".concat(measureValue / maxValue * 100, "%"),
        backgroundColor: resolveColor(index, measure === null || measure === void 0 ? void 0 : (_measure$colors = measure.colors) === null || _measure$colors === void 0 ? void 0 : _measure$colors[index])
      }
    })));
  })));
});
MicroBarChart.displayName = 'MicroBarChart';

export { MicroBarChart };
//# sourceMappingURL=MicroBarChart.js.map
