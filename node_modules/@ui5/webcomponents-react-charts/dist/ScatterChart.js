import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { useConsolidatedRef, usePassThroughHtmlProps, useIsRTL } from '@ui5/webcomponents-react-base/dist/hooks';
import { ThemingParameters } from '@ui5/webcomponents-react-base/dist/ThemingParameters';
import { debounce, enrichEventWithDetails } from '@ui5/webcomponents-react-base/dist/Utils';
import { ChartContainer } from '@ui5/webcomponents-react-charts/dist/components/ChartContainer';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/dist/components/YAxisTicks';
import { ScatterChartPlaceholder } from '@ui5/webcomponents-react-charts/dist/ScatterChartPlaceholder';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/dist/useLegendItemClick';
import React, { useMemo, useState, useRef, useEffect, useCallback, forwardRef } from 'react';
import { ScatterChart as ScatterChart$1, CartesianGrid, XAxis, YAxis, ZAxis, Scatter, Legend, ReferenceLine, Label, Tooltip } from 'recharts';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { getTextWidth } from '@ui5/webcomponents-react-charts/dist/Utils';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabel = function useLongestYAxisLabel(dataset, elements) {
  return useMemo(function () {
    var labelLength = 0;
    var primaryElement = elements[0];

    if (dataset instanceof Array && primaryElement) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return primaryElement.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      labelLength = Math.max.apply(Math, _toConsumableArray(dataset.map(resolveAllMeasureLabels).flat().map(getTextWidth)));
      labelLength += 8;
    }

    labelLength = Math.min(labelLength, defaultMaxYAxisWidth);
    return [labelLength, {
      marginLeft: labelLength,
      maxWidth: "calc(100% - ".concat(labelLength + 10, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
}; // we need type any due to recharts typing error

var xAxisPadding = {
  left: 25,
  right: 25
};

var measureDefaults = {
  formatter: defaultFormatter
};
/**
 *
 * A `ScatterChart` is a data visualization that displays multiple circles (bubbles) in a two-dimensional plot.
 *
 * Most commonly, a scatter chart displays the values of three numeric variables,where each observation's data is
 * shown by a circle, while the horizontal and vertical positions of the bubble show the values of two other variables.
 */

var ScatterChart = /*#__PURE__*/forwardRef(function (props, ref) {
  var _ref, _xMeasure$interval;

  var dataset = props.dataset,
      loading = props.loading,
      noLegend = props.noLegend,
      noAnimation = props.noAnimation,
      tooltipConfig = props.tooltipConfig,
      onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      onClick = props.onClick,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot,
      ChartPlaceholder = props.ChartPlaceholder;
  var chartConfig = useMemo(function () {
    return _objectSpread({
      yAxisVisible: false,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures([], props.measures, {}, measureDefaults),
      measures = _usePrepareDimensions.measures;

  var tooltipValueFormatter = useTooltipFormatter(measures);
  var chartRef = useConsolidatedRef(ref);
  var preventOnClickCall = useRef(false);
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var onClickInternal = useCallback(function (payload, event) {
    if (typeof onClick === 'function' && !preventOnClickCall.current) {
      var _payload$activePayloa, _payload$activePayloa2;

      onClick(enrichEventWithDetails(event, {
        payload: payload === null || payload === void 0 ? void 0 : (_payload$activePayloa = payload.activePayload) === null || _payload$activePayloa === void 0 ? void 0 : (_payload$activePayloa2 = _payload$activePayloa[0]) === null || _payload$activePayloa2 === void 0 ? void 0 : _payload$activePayloa2.payload,
        activePayloads: payload === null || payload === void 0 ? void 0 : payload.activePayload
      }));
    }

    if (preventOnClickCall.current) {
      preventOnClickCall.current = false;
    }
  }, [onClick, preventOnClickCall.current]);
  var onDataPointClickInternal = useCallback(function (payload, eventOrIndex, event) {
    if (payload && onDataPointClick) {
      onDataPointClick(enrichEventWithDetails(event, {
        value: payload.node,
        dataKey: payload.zAxis.dataKey,
        dataIndex: eventOrIndex,
        payload: payload.payload
      }));
      preventOnClickCall.current = true;
    }
  }, [onDataPointClick, preventOnClickCall.current]);
  var isBigDataSet = (_ref = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30) !== null && _ref !== void 0 ? _ref : false;
  var xMeasure = measures.find(function (_ref2) {
    var axis = _ref2.axis;
    return axis === 'x';
  });
  var yMeasure = measures.find(function (_ref3) {
    var axis = _ref3.axis;
    return axis === 'y';
  });
  var zMeasure = measures.find(function (_ref4) {
    var axis = _ref4.axis;
    return axis === 'z';
  });

  var _useLongestYAxisLabel = useLongestYAxisLabel(dataset === null || dataset === void 0 ? void 0 : dataset[0].data, [yMeasure]),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      yAxisWidth = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var xAxisHeights = useObserveXAxisHeights(chartRef, 1);
  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);
  var passThroughProps = usePassThroughHtmlProps(props, ['onDataPointClick', 'onLegendClick', 'onClick']);
  var isRTL = useIsRTL(chartRef);
  return /*#__PURE__*/React.createElement(ChartContainer, _extends({
    dataset: dataset,
    loading: loading,
    Placeholder: ChartPlaceholder !== null && ChartPlaceholder !== void 0 ? ChartPlaceholder : ScatterChartPlaceholder,
    ref: chartRef,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, passThroughProps), /*#__PURE__*/React.createElement(ScatterChart$1, {
    onClick: onClickInternal,
    margin: marginChart,
    className: typeof onDataPointClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && /*#__PURE__*/React.createElement(XAxis, {
    type: 'number',
    key: xMeasure === null || xMeasure === void 0 ? void 0 : xMeasure.accessor,
    name: xMeasure === null || xMeasure === void 0 ? void 0 : xMeasure.label,
    dataKey: xMeasure === null || xMeasure === void 0 ? void 0 : xMeasure.accessor,
    xAxisId: 0,
    interval: (_xMeasure$interval = xMeasure === null || xMeasure === void 0 ? void 0 : xMeasure.interval) !== null && _xMeasure$interval !== void 0 ? _xMeasure$interval : isBigDataSet ? 'preserveStart' : 0,
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: xMeasure
    }),
    padding: xAxisPadding,
    height: xAxisHeights[0],
    reversed: isRTL // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ,
    label: xMeasure !== null && xMeasure !== void 0 && xMeasure.label ? {
      value: xMeasure === null || xMeasure === void 0 ? void 0 : xMeasure.label,
      dy: 15,
      position: 'insideRight'
    } : 0
  }), /*#__PURE__*/React.createElement(YAxis // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  , {
    label: yMeasure !== null && yMeasure !== void 0 && yMeasure.label ? {
      value: yMeasure === null || yMeasure === void 0 ? void 0 : yMeasure.label,
      angle: -90,
      position: isRTL ? 'insideRight' : 'insideLeft'
    } : false,
    type: 'number',
    name: yMeasure === null || yMeasure === void 0 ? void 0 : yMeasure.label,
    axisLine: chartConfig.yAxisVisible,
    tickLine: tickLineConfig,
    key: yMeasure === null || yMeasure === void 0 ? void 0 : yMeasure.accessor,
    dataKey: yMeasure === null || yMeasure === void 0 ? void 0 : yMeasure.accessor,
    tickFormatter: yMeasure === null || yMeasure === void 0 ? void 0 : yMeasure.formatter,
    interval: 0,
    tick: /*#__PURE__*/React.createElement(YAxisTicks, {
      config: yMeasure
    }),
    width: yMeasure !== null && yMeasure !== void 0 && yMeasure.label ? yAxisWidth + 10 : yAxisWidth,
    margin: yMeasure !== null && yMeasure !== void 0 && yMeasure.label ? {
      left: 200
    } : 0,
    orientation: isRTL === true ? 'right' : 'left'
  }), /*#__PURE__*/React.createElement(ZAxis, {
    name: zMeasure === null || zMeasure === void 0 ? void 0 : zMeasure.label,
    dataKey: zMeasure === null || zMeasure === void 0 ? void 0 : zMeasure.accessor,
    range: [0, 5000],
    key: zMeasure === null || zMeasure === void 0 ? void 0 : zMeasure.accessor
  }), dataset === null || dataset === void 0 ? void 0 : dataset.map(function (dataSet, index) {
    var _dataSet$color;

    return /*#__PURE__*/React.createElement(Scatter, {
      className: typeof onDataPointClick === 'function' ? 'has-click-handler' : undefined // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ,
      onMouseDown: onDataPointClickInternal,
      opacity: dataSet.opacity,
      data: dataSet === null || dataSet === void 0 ? void 0 : dataSet.data,
      name: dataSet === null || dataSet === void 0 ? void 0 : dataSet.label,
      key: dataSet === null || dataSet === void 0 ? void 0 : dataSet.label,
      fill: (_dataSet$color = dataSet === null || dataSet === void 0 ? void 0 : dataSet.color) !== null && _dataSet$color !== void 0 ? _dataSet$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      isAnimationActive: noAnimation === false
    });
  }), !noLegend &&
  /*#__PURE__*/
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    y: chartConfig.referenceLine.value
  }, /*#__PURE__*/React.createElement(Label, null, chartConfig.referenceLine.label)), chartConfig.referenceLineX && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLineX.color,
    x: chartConfig.referenceLineX.value
  }, /*#__PURE__*/React.createElement(Label, null, chartConfig.referenceLineX.label)), /*#__PURE__*/React.createElement(Tooltip, _extends({
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle
  }, tooltipConfig)), props.children));
});
ScatterChart.defaultProps = {
  noLegend: false,
  noAnimation: false
};
ScatterChart.displayName = 'ScatterChart';

export { ScatterChart };
//# sourceMappingURL=ScatterChart.js.map
